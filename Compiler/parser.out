Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> Program
Rule 1     Program -> PROGRAM ID LEFTBRACKET variable block RIGHTBRACKET
Rule 2     variable -> VAR ID variables COLON datatype SEMICOLON variable
Rule 3     variable -> empty
Rule 4     variables -> COMMA ID variables
Rule 5     variables -> empty
Rule 6     datatype -> INT
Rule 7     datatype -> REAL
Rule 8     datatype -> BOOL
Rule 9     datatype -> STR
Rule 10    block -> BEGIN SEMICOLON statement END SEMICOLON
Rule 11    statement -> writestatement statement
Rule 12    statement -> assignstatement statement
Rule 13    statement -> ifstatement statement
Rule 14    statement -> whileloop statement
Rule 15    statement -> forloop statement
Rule 16    statement -> empty
Rule 17    writestatement -> WRITE LEFTPARENTHESIS expression RIGHTPARENTHESIS SEMICOLON
Rule 18    assignstatement -> ID ASSIGN expression SEMICOLON
Rule 19    ifstatement -> IF LEFTPARENTHESIS expression RIGHTPARENTHESIS THEN LEFTBRACKET statement RIGHTBRACKET elsestatement
Rule 20    elsestatement -> ELSE LEFTBRACKET statement RIGHTBRACKET
Rule 21    elsestatement -> empty
Rule 22    whileloop -> WHILE LEFTPARENTHESIS expression RIGHTPARENTHESIS DO LEFTBRACKET statement RIGHTBRACKET
Rule 23    forloop -> FOR LEFTPARENTHESIS ID ASSIGN expression SEMICOLON expression SEMICOLON formodifier RIGHTPARENTHESIS LEFTBRACKET statement RIGHTBRACKET
Rule 24    formodifier -> ID PLUSPLUS
Rule 25    formodifier -> ID MINUSMINUS
Rule 26    expression -> simpleexpression
Rule 27    expression -> simpleexpression relationaloperators simpleexpression
Rule 28    relationaloperators -> EQUAL
Rule 29    relationaloperators -> LESSER
Rule 30    relationaloperators -> GREATER
Rule 31    relationaloperators -> LESSEREQUAL
Rule 32    relationaloperators -> GREATEREQUAL
Rule 33    simpleexpression -> term
Rule 34    simpleexpression -> term PLUS simpleexpression
Rule 35    simpleexpression -> term MINUS simpleexpression
Rule 36    simpleexpression -> term OR simpleexpression
Rule 37    term -> fact
Rule 38    term -> fact TIMES term
Rule 39    term -> fact MINUS term
Rule 40    term -> fact DIVIDE term
Rule 41    term -> fact AND term
Rule 42    fact -> unaryoperator ID
Rule 43    fact -> unaryoperator LEFTPARENTHESIS expression RIGHTPARENTHESIS
Rule 44    fact -> unaryoperator INTEGER
Rule 45    fact -> unaryoperator NUMBER
Rule 46    fact -> unaryoperator STRING
Rule 47    fact -> unaryoperator BOOLEAN
Rule 48    unaryoperator -> PLUS
Rule 49    unaryoperator -> MINUS
Rule 50    unaryoperator -> empty
Rule 51    empty -> <empty>

Terminals, with rules where they appear

AND                  : 41
ASSIGN               : 18 23
BEGIN                : 10
BOOL                 : 8
BOOLEAN              : 47
COLON                : 2
COMMA                : 4
DIVIDE               : 40
DO                   : 22
ELSE                 : 20
END                  : 10
EQUAL                : 28
FOR                  : 23
GREATER              : 30
GREATEREQUAL         : 32
ID                   : 1 2 4 18 23 24 25 42
IF                   : 19
INT                  : 6
INTEGER              : 44
LEFTBRACKET          : 1 19 20 22 23
LEFTPARENTHESIS      : 17 19 22 23 43
LESSER               : 29
LESSEREQUAL          : 31
MINUS                : 35 39 49
MINUSMINUS           : 25
NUMBER               : 45
OR                   : 36
PLUS                 : 34 48
PLUSPLUS             : 24
PROGRAM              : 1
REAL                 : 7
RIGHTBRACKET         : 1 19 20 22 23
RIGHTPARENTHESIS     : 17 19 22 23 43
SEMICOLON            : 2 10 10 17 18 23 23
STR                  : 9
STRING               : 46
THEN                 : 19
TIMES                : 38
VAR                  : 2
WHILE                : 22
WRITE                : 17
error                : 

Nonterminals, with rules where they appear

Program              : 0
assignstatement      : 12
block                : 1
datatype             : 2
elsestatement        : 19
empty                : 3 5 16 21 50
expression           : 17 18 19 22 23 23 43
fact                 : 37 38 39 40 41
forloop              : 15
formodifier          : 23
ifstatement          : 13
relationaloperators  : 27
simpleexpression     : 26 27 27 34 35 36
statement            : 10 11 12 13 14 15 19 20 22 23
term                 : 33 34 35 36 38 39 40 41
unaryoperator        : 42 43 44 45 46 47
variable             : 1 2
variables            : 2 4
whileloop            : 14
writestatement       : 11

Parsing method: LALR

state 0

    (0) S' -> . Program
    (1) Program -> . PROGRAM ID LEFTBRACKET variable block RIGHTBRACKET

    PROGRAM         shift and go to state 2

    Program                        shift and go to state 1

state 1

    (0) S' -> Program .



state 2

    (1) Program -> PROGRAM . ID LEFTBRACKET variable block RIGHTBRACKET

    ID              shift and go to state 3


state 3

    (1) Program -> PROGRAM ID . LEFTBRACKET variable block RIGHTBRACKET

    LEFTBRACKET     shift and go to state 4


state 4

    (1) Program -> PROGRAM ID LEFTBRACKET . variable block RIGHTBRACKET
    (2) variable -> . VAR ID variables COLON datatype SEMICOLON variable
    (3) variable -> . empty
    (51) empty -> .

    VAR             shift and go to state 6
    BEGIN           reduce using rule 51 (empty -> .)

    variable                       shift and go to state 5
    empty                          shift and go to state 7

state 5

    (1) Program -> PROGRAM ID LEFTBRACKET variable . block RIGHTBRACKET
    (10) block -> . BEGIN SEMICOLON statement END SEMICOLON

    BEGIN           shift and go to state 9

    block                          shift and go to state 8

state 6

    (2) variable -> VAR . ID variables COLON datatype SEMICOLON variable

    ID              shift and go to state 10


state 7

    (3) variable -> empty .

    BEGIN           reduce using rule 3 (variable -> empty .)


state 8

    (1) Program -> PROGRAM ID LEFTBRACKET variable block . RIGHTBRACKET

    RIGHTBRACKET    shift and go to state 11


state 9

    (10) block -> BEGIN . SEMICOLON statement END SEMICOLON

    SEMICOLON       shift and go to state 12


state 10

    (2) variable -> VAR ID . variables COLON datatype SEMICOLON variable
    (4) variables -> . COMMA ID variables
    (5) variables -> . empty
    (51) empty -> .

    COMMA           shift and go to state 14
    COLON           reduce using rule 51 (empty -> .)

    variables                      shift and go to state 13
    empty                          shift and go to state 15

state 11

    (1) Program -> PROGRAM ID LEFTBRACKET variable block RIGHTBRACKET .

    $end            reduce using rule 1 (Program -> PROGRAM ID LEFTBRACKET variable block RIGHTBRACKET .)


state 12

    (10) block -> BEGIN SEMICOLON . statement END SEMICOLON
    (11) statement -> . writestatement statement
    (12) statement -> . assignstatement statement
    (13) statement -> . ifstatement statement
    (14) statement -> . whileloop statement
    (15) statement -> . forloop statement
    (16) statement -> . empty
    (17) writestatement -> . WRITE LEFTPARENTHESIS expression RIGHTPARENTHESIS SEMICOLON
    (18) assignstatement -> . ID ASSIGN expression SEMICOLON
    (19) ifstatement -> . IF LEFTPARENTHESIS expression RIGHTPARENTHESIS THEN LEFTBRACKET statement RIGHTBRACKET elsestatement
    (22) whileloop -> . WHILE LEFTPARENTHESIS expression RIGHTPARENTHESIS DO LEFTBRACKET statement RIGHTBRACKET
    (23) forloop -> . FOR LEFTPARENTHESIS ID ASSIGN expression SEMICOLON expression SEMICOLON formodifier RIGHTPARENTHESIS LEFTBRACKET statement RIGHTBRACKET
    (51) empty -> .

    WRITE           shift and go to state 23
    ID              shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    END             reduce using rule 51 (empty -> .)

    statement                      shift and go to state 16
    writestatement                 shift and go to state 17
    assignstatement                shift and go to state 18
    ifstatement                    shift and go to state 19
    whileloop                      shift and go to state 20
    forloop                        shift and go to state 21
    empty                          shift and go to state 22

state 13

    (2) variable -> VAR ID variables . COLON datatype SEMICOLON variable

    COLON           shift and go to state 28


state 14

    (4) variables -> COMMA . ID variables

    ID              shift and go to state 29


state 15

    (5) variables -> empty .

    COLON           reduce using rule 5 (variables -> empty .)


state 16

    (10) block -> BEGIN SEMICOLON statement . END SEMICOLON

    END             shift and go to state 30


state 17

    (11) statement -> writestatement . statement
    (11) statement -> . writestatement statement
    (12) statement -> . assignstatement statement
    (13) statement -> . ifstatement statement
    (14) statement -> . whileloop statement
    (15) statement -> . forloop statement
    (16) statement -> . empty
    (17) writestatement -> . WRITE LEFTPARENTHESIS expression RIGHTPARENTHESIS SEMICOLON
    (18) assignstatement -> . ID ASSIGN expression SEMICOLON
    (19) ifstatement -> . IF LEFTPARENTHESIS expression RIGHTPARENTHESIS THEN LEFTBRACKET statement RIGHTBRACKET elsestatement
    (22) whileloop -> . WHILE LEFTPARENTHESIS expression RIGHTPARENTHESIS DO LEFTBRACKET statement RIGHTBRACKET
    (23) forloop -> . FOR LEFTPARENTHESIS ID ASSIGN expression SEMICOLON expression SEMICOLON formodifier RIGHTPARENTHESIS LEFTBRACKET statement RIGHTBRACKET
    (51) empty -> .

    WRITE           shift and go to state 23
    ID              shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    END             reduce using rule 51 (empty -> .)
    RIGHTBRACKET    reduce using rule 51 (empty -> .)

    writestatement                 shift and go to state 17
    statement                      shift and go to state 31
    assignstatement                shift and go to state 18
    ifstatement                    shift and go to state 19
    whileloop                      shift and go to state 20
    forloop                        shift and go to state 21
    empty                          shift and go to state 22

state 18

    (12) statement -> assignstatement . statement
    (11) statement -> . writestatement statement
    (12) statement -> . assignstatement statement
    (13) statement -> . ifstatement statement
    (14) statement -> . whileloop statement
    (15) statement -> . forloop statement
    (16) statement -> . empty
    (17) writestatement -> . WRITE LEFTPARENTHESIS expression RIGHTPARENTHESIS SEMICOLON
    (18) assignstatement -> . ID ASSIGN expression SEMICOLON
    (19) ifstatement -> . IF LEFTPARENTHESIS expression RIGHTPARENTHESIS THEN LEFTBRACKET statement RIGHTBRACKET elsestatement
    (22) whileloop -> . WHILE LEFTPARENTHESIS expression RIGHTPARENTHESIS DO LEFTBRACKET statement RIGHTBRACKET
    (23) forloop -> . FOR LEFTPARENTHESIS ID ASSIGN expression SEMICOLON expression SEMICOLON formodifier RIGHTPARENTHESIS LEFTBRACKET statement RIGHTBRACKET
    (51) empty -> .

    WRITE           shift and go to state 23
    ID              shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    END             reduce using rule 51 (empty -> .)
    RIGHTBRACKET    reduce using rule 51 (empty -> .)

    assignstatement                shift and go to state 18
    statement                      shift and go to state 32
    writestatement                 shift and go to state 17
    ifstatement                    shift and go to state 19
    whileloop                      shift and go to state 20
    forloop                        shift and go to state 21
    empty                          shift and go to state 22

state 19

    (13) statement -> ifstatement . statement
    (11) statement -> . writestatement statement
    (12) statement -> . assignstatement statement
    (13) statement -> . ifstatement statement
    (14) statement -> . whileloop statement
    (15) statement -> . forloop statement
    (16) statement -> . empty
    (17) writestatement -> . WRITE LEFTPARENTHESIS expression RIGHTPARENTHESIS SEMICOLON
    (18) assignstatement -> . ID ASSIGN expression SEMICOLON
    (19) ifstatement -> . IF LEFTPARENTHESIS expression RIGHTPARENTHESIS THEN LEFTBRACKET statement RIGHTBRACKET elsestatement
    (22) whileloop -> . WHILE LEFTPARENTHESIS expression RIGHTPARENTHESIS DO LEFTBRACKET statement RIGHTBRACKET
    (23) forloop -> . FOR LEFTPARENTHESIS ID ASSIGN expression SEMICOLON expression SEMICOLON formodifier RIGHTPARENTHESIS LEFTBRACKET statement RIGHTBRACKET
    (51) empty -> .

    WRITE           shift and go to state 23
    ID              shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    END             reduce using rule 51 (empty -> .)
    RIGHTBRACKET    reduce using rule 51 (empty -> .)

    ifstatement                    shift and go to state 19
    statement                      shift and go to state 33
    writestatement                 shift and go to state 17
    assignstatement                shift and go to state 18
    whileloop                      shift and go to state 20
    forloop                        shift and go to state 21
    empty                          shift and go to state 22

state 20

    (14) statement -> whileloop . statement
    (11) statement -> . writestatement statement
    (12) statement -> . assignstatement statement
    (13) statement -> . ifstatement statement
    (14) statement -> . whileloop statement
    (15) statement -> . forloop statement
    (16) statement -> . empty
    (17) writestatement -> . WRITE LEFTPARENTHESIS expression RIGHTPARENTHESIS SEMICOLON
    (18) assignstatement -> . ID ASSIGN expression SEMICOLON
    (19) ifstatement -> . IF LEFTPARENTHESIS expression RIGHTPARENTHESIS THEN LEFTBRACKET statement RIGHTBRACKET elsestatement
    (22) whileloop -> . WHILE LEFTPARENTHESIS expression RIGHTPARENTHESIS DO LEFTBRACKET statement RIGHTBRACKET
    (23) forloop -> . FOR LEFTPARENTHESIS ID ASSIGN expression SEMICOLON expression SEMICOLON formodifier RIGHTPARENTHESIS LEFTBRACKET statement RIGHTBRACKET
    (51) empty -> .

    WRITE           shift and go to state 23
    ID              shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    END             reduce using rule 51 (empty -> .)
    RIGHTBRACKET    reduce using rule 51 (empty -> .)

    whileloop                      shift and go to state 20
    statement                      shift and go to state 34
    writestatement                 shift and go to state 17
    assignstatement                shift and go to state 18
    ifstatement                    shift and go to state 19
    forloop                        shift and go to state 21
    empty                          shift and go to state 22

state 21

    (15) statement -> forloop . statement
    (11) statement -> . writestatement statement
    (12) statement -> . assignstatement statement
    (13) statement -> . ifstatement statement
    (14) statement -> . whileloop statement
    (15) statement -> . forloop statement
    (16) statement -> . empty
    (17) writestatement -> . WRITE LEFTPARENTHESIS expression RIGHTPARENTHESIS SEMICOLON
    (18) assignstatement -> . ID ASSIGN expression SEMICOLON
    (19) ifstatement -> . IF LEFTPARENTHESIS expression RIGHTPARENTHESIS THEN LEFTBRACKET statement RIGHTBRACKET elsestatement
    (22) whileloop -> . WHILE LEFTPARENTHESIS expression RIGHTPARENTHESIS DO LEFTBRACKET statement RIGHTBRACKET
    (23) forloop -> . FOR LEFTPARENTHESIS ID ASSIGN expression SEMICOLON expression SEMICOLON formodifier RIGHTPARENTHESIS LEFTBRACKET statement RIGHTBRACKET
    (51) empty -> .

    WRITE           shift and go to state 23
    ID              shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    END             reduce using rule 51 (empty -> .)
    RIGHTBRACKET    reduce using rule 51 (empty -> .)

    forloop                        shift and go to state 21
    statement                      shift and go to state 35
    writestatement                 shift and go to state 17
    assignstatement                shift and go to state 18
    ifstatement                    shift and go to state 19
    whileloop                      shift and go to state 20
    empty                          shift and go to state 22

state 22

    (16) statement -> empty .

    END             reduce using rule 16 (statement -> empty .)
    RIGHTBRACKET    reduce using rule 16 (statement -> empty .)


state 23

    (17) writestatement -> WRITE . LEFTPARENTHESIS expression RIGHTPARENTHESIS SEMICOLON

    LEFTPARENTHESIS shift and go to state 36


state 24

    (18) assignstatement -> ID . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 37


state 25

    (19) ifstatement -> IF . LEFTPARENTHESIS expression RIGHTPARENTHESIS THEN LEFTBRACKET statement RIGHTBRACKET elsestatement

    LEFTPARENTHESIS shift and go to state 38


state 26

    (22) whileloop -> WHILE . LEFTPARENTHESIS expression RIGHTPARENTHESIS DO LEFTBRACKET statement RIGHTBRACKET

    LEFTPARENTHESIS shift and go to state 39


state 27

    (23) forloop -> FOR . LEFTPARENTHESIS ID ASSIGN expression SEMICOLON expression SEMICOLON formodifier RIGHTPARENTHESIS LEFTBRACKET statement RIGHTBRACKET

    LEFTPARENTHESIS shift and go to state 40


state 28

    (2) variable -> VAR ID variables COLON . datatype SEMICOLON variable
    (6) datatype -> . INT
    (7) datatype -> . REAL
    (8) datatype -> . BOOL
    (9) datatype -> . STR

    INT             shift and go to state 42
    REAL            shift and go to state 43
    BOOL            shift and go to state 44
    STR             shift and go to state 45

    datatype                       shift and go to state 41

state 29

    (4) variables -> COMMA ID . variables
    (4) variables -> . COMMA ID variables
    (5) variables -> . empty
    (51) empty -> .

    COMMA           shift and go to state 14
    COLON           reduce using rule 51 (empty -> .)

    variables                      shift and go to state 46
    empty                          shift and go to state 15

state 30

    (10) block -> BEGIN SEMICOLON statement END . SEMICOLON

    SEMICOLON       shift and go to state 47


state 31

    (11) statement -> writestatement statement .

    END             reduce using rule 11 (statement -> writestatement statement .)
    RIGHTBRACKET    reduce using rule 11 (statement -> writestatement statement .)


state 32

    (12) statement -> assignstatement statement .

    END             reduce using rule 12 (statement -> assignstatement statement .)
    RIGHTBRACKET    reduce using rule 12 (statement -> assignstatement statement .)


state 33

    (13) statement -> ifstatement statement .

    END             reduce using rule 13 (statement -> ifstatement statement .)
    RIGHTBRACKET    reduce using rule 13 (statement -> ifstatement statement .)


state 34

    (14) statement -> whileloop statement .

    END             reduce using rule 14 (statement -> whileloop statement .)
    RIGHTBRACKET    reduce using rule 14 (statement -> whileloop statement .)


state 35

    (15) statement -> forloop statement .

    END             reduce using rule 15 (statement -> forloop statement .)
    RIGHTBRACKET    reduce using rule 15 (statement -> forloop statement .)


state 36

    (17) writestatement -> WRITE LEFTPARENTHESIS . expression RIGHTPARENTHESIS SEMICOLON
    (26) expression -> . simpleexpression
    (27) expression -> . simpleexpression relationaloperators simpleexpression
    (33) simpleexpression -> . term
    (34) simpleexpression -> . term PLUS simpleexpression
    (35) simpleexpression -> . term MINUS simpleexpression
    (36) simpleexpression -> . term OR simpleexpression
    (37) term -> . fact
    (38) term -> . fact TIMES term
    (39) term -> . fact MINUS term
    (40) term -> . fact DIVIDE term
    (41) term -> . fact AND term
    (42) fact -> . unaryoperator ID
    (43) fact -> . unaryoperator LEFTPARENTHESIS expression RIGHTPARENTHESIS
    (44) fact -> . unaryoperator INTEGER
    (45) fact -> . unaryoperator NUMBER
    (46) fact -> . unaryoperator STRING
    (47) fact -> . unaryoperator BOOLEAN
    (48) unaryoperator -> . PLUS
    (49) unaryoperator -> . MINUS
    (50) unaryoperator -> . empty
    (51) empty -> .

    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    ID              reduce using rule 51 (empty -> .)
    LEFTPARENTHESIS reduce using rule 51 (empty -> .)
    INTEGER         reduce using rule 51 (empty -> .)
    NUMBER          reduce using rule 51 (empty -> .)
    STRING          reduce using rule 51 (empty -> .)
    BOOLEAN         reduce using rule 51 (empty -> .)

    expression                     shift and go to state 48
    simpleexpression               shift and go to state 49
    term                           shift and go to state 50
    fact                           shift and go to state 53
    unaryoperator                  shift and go to state 54
    empty                          shift and go to state 55

state 37

    (18) assignstatement -> ID ASSIGN . expression SEMICOLON
    (26) expression -> . simpleexpression
    (27) expression -> . simpleexpression relationaloperators simpleexpression
    (33) simpleexpression -> . term
    (34) simpleexpression -> . term PLUS simpleexpression
    (35) simpleexpression -> . term MINUS simpleexpression
    (36) simpleexpression -> . term OR simpleexpression
    (37) term -> . fact
    (38) term -> . fact TIMES term
    (39) term -> . fact MINUS term
    (40) term -> . fact DIVIDE term
    (41) term -> . fact AND term
    (42) fact -> . unaryoperator ID
    (43) fact -> . unaryoperator LEFTPARENTHESIS expression RIGHTPARENTHESIS
    (44) fact -> . unaryoperator INTEGER
    (45) fact -> . unaryoperator NUMBER
    (46) fact -> . unaryoperator STRING
    (47) fact -> . unaryoperator BOOLEAN
    (48) unaryoperator -> . PLUS
    (49) unaryoperator -> . MINUS
    (50) unaryoperator -> . empty
    (51) empty -> .

    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    ID              reduce using rule 51 (empty -> .)
    LEFTPARENTHESIS reduce using rule 51 (empty -> .)
    INTEGER         reduce using rule 51 (empty -> .)
    NUMBER          reduce using rule 51 (empty -> .)
    STRING          reduce using rule 51 (empty -> .)
    BOOLEAN         reduce using rule 51 (empty -> .)

    expression                     shift and go to state 56
    simpleexpression               shift and go to state 49
    term                           shift and go to state 50
    fact                           shift and go to state 53
    unaryoperator                  shift and go to state 54
    empty                          shift and go to state 55

state 38

    (19) ifstatement -> IF LEFTPARENTHESIS . expression RIGHTPARENTHESIS THEN LEFTBRACKET statement RIGHTBRACKET elsestatement
    (26) expression -> . simpleexpression
    (27) expression -> . simpleexpression relationaloperators simpleexpression
    (33) simpleexpression -> . term
    (34) simpleexpression -> . term PLUS simpleexpression
    (35) simpleexpression -> . term MINUS simpleexpression
    (36) simpleexpression -> . term OR simpleexpression
    (37) term -> . fact
    (38) term -> . fact TIMES term
    (39) term -> . fact MINUS term
    (40) term -> . fact DIVIDE term
    (41) term -> . fact AND term
    (42) fact -> . unaryoperator ID
    (43) fact -> . unaryoperator LEFTPARENTHESIS expression RIGHTPARENTHESIS
    (44) fact -> . unaryoperator INTEGER
    (45) fact -> . unaryoperator NUMBER
    (46) fact -> . unaryoperator STRING
    (47) fact -> . unaryoperator BOOLEAN
    (48) unaryoperator -> . PLUS
    (49) unaryoperator -> . MINUS
    (50) unaryoperator -> . empty
    (51) empty -> .

    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    ID              reduce using rule 51 (empty -> .)
    LEFTPARENTHESIS reduce using rule 51 (empty -> .)
    INTEGER         reduce using rule 51 (empty -> .)
    NUMBER          reduce using rule 51 (empty -> .)
    STRING          reduce using rule 51 (empty -> .)
    BOOLEAN         reduce using rule 51 (empty -> .)

    expression                     shift and go to state 57
    simpleexpression               shift and go to state 49
    term                           shift and go to state 50
    fact                           shift and go to state 53
    unaryoperator                  shift and go to state 54
    empty                          shift and go to state 55

state 39

    (22) whileloop -> WHILE LEFTPARENTHESIS . expression RIGHTPARENTHESIS DO LEFTBRACKET statement RIGHTBRACKET
    (26) expression -> . simpleexpression
    (27) expression -> . simpleexpression relationaloperators simpleexpression
    (33) simpleexpression -> . term
    (34) simpleexpression -> . term PLUS simpleexpression
    (35) simpleexpression -> . term MINUS simpleexpression
    (36) simpleexpression -> . term OR simpleexpression
    (37) term -> . fact
    (38) term -> . fact TIMES term
    (39) term -> . fact MINUS term
    (40) term -> . fact DIVIDE term
    (41) term -> . fact AND term
    (42) fact -> . unaryoperator ID
    (43) fact -> . unaryoperator LEFTPARENTHESIS expression RIGHTPARENTHESIS
    (44) fact -> . unaryoperator INTEGER
    (45) fact -> . unaryoperator NUMBER
    (46) fact -> . unaryoperator STRING
    (47) fact -> . unaryoperator BOOLEAN
    (48) unaryoperator -> . PLUS
    (49) unaryoperator -> . MINUS
    (50) unaryoperator -> . empty
    (51) empty -> .

    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    ID              reduce using rule 51 (empty -> .)
    LEFTPARENTHESIS reduce using rule 51 (empty -> .)
    INTEGER         reduce using rule 51 (empty -> .)
    NUMBER          reduce using rule 51 (empty -> .)
    STRING          reduce using rule 51 (empty -> .)
    BOOLEAN         reduce using rule 51 (empty -> .)

    expression                     shift and go to state 58
    simpleexpression               shift and go to state 49
    term                           shift and go to state 50
    fact                           shift and go to state 53
    unaryoperator                  shift and go to state 54
    empty                          shift and go to state 55

state 40

    (23) forloop -> FOR LEFTPARENTHESIS . ID ASSIGN expression SEMICOLON expression SEMICOLON formodifier RIGHTPARENTHESIS LEFTBRACKET statement RIGHTBRACKET

    ID              shift and go to state 59


state 41

    (2) variable -> VAR ID variables COLON datatype . SEMICOLON variable

    SEMICOLON       shift and go to state 60


state 42

    (6) datatype -> INT .

    SEMICOLON       reduce using rule 6 (datatype -> INT .)


state 43

    (7) datatype -> REAL .

    SEMICOLON       reduce using rule 7 (datatype -> REAL .)


state 44

    (8) datatype -> BOOL .

    SEMICOLON       reduce using rule 8 (datatype -> BOOL .)


state 45

    (9) datatype -> STR .

    SEMICOLON       reduce using rule 9 (datatype -> STR .)


state 46

    (4) variables -> COMMA ID variables .

    COLON           reduce using rule 4 (variables -> COMMA ID variables .)


state 47

    (10) block -> BEGIN SEMICOLON statement END SEMICOLON .

    RIGHTBRACKET    reduce using rule 10 (block -> BEGIN SEMICOLON statement END SEMICOLON .)


state 48

    (17) writestatement -> WRITE LEFTPARENTHESIS expression . RIGHTPARENTHESIS SEMICOLON

    RIGHTPARENTHESIS shift and go to state 61


state 49

    (26) expression -> simpleexpression .
    (27) expression -> simpleexpression . relationaloperators simpleexpression
    (28) relationaloperators -> . EQUAL
    (29) relationaloperators -> . LESSER
    (30) relationaloperators -> . GREATER
    (31) relationaloperators -> . LESSEREQUAL
    (32) relationaloperators -> . GREATEREQUAL

    RIGHTPARENTHESIS reduce using rule 26 (expression -> simpleexpression .)
    SEMICOLON       reduce using rule 26 (expression -> simpleexpression .)
    EQUAL           shift and go to state 63
    LESSER          shift and go to state 64
    GREATER         shift and go to state 65
    LESSEREQUAL     shift and go to state 66
    GREATEREQUAL    shift and go to state 67

    relationaloperators            shift and go to state 62

state 50

    (33) simpleexpression -> term .
    (34) simpleexpression -> term . PLUS simpleexpression
    (35) simpleexpression -> term . MINUS simpleexpression
    (36) simpleexpression -> term . OR simpleexpression

    EQUAL           reduce using rule 33 (simpleexpression -> term .)
    LESSER          reduce using rule 33 (simpleexpression -> term .)
    GREATER         reduce using rule 33 (simpleexpression -> term .)
    LESSEREQUAL     reduce using rule 33 (simpleexpression -> term .)
    GREATEREQUAL    reduce using rule 33 (simpleexpression -> term .)
    RIGHTPARENTHESIS reduce using rule 33 (simpleexpression -> term .)
    SEMICOLON       reduce using rule 33 (simpleexpression -> term .)
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    OR              shift and go to state 70


state 51

    (48) unaryoperator -> PLUS .

    ID              reduce using rule 48 (unaryoperator -> PLUS .)
    LEFTPARENTHESIS reduce using rule 48 (unaryoperator -> PLUS .)
    INTEGER         reduce using rule 48 (unaryoperator -> PLUS .)
    NUMBER          reduce using rule 48 (unaryoperator -> PLUS .)
    STRING          reduce using rule 48 (unaryoperator -> PLUS .)
    BOOLEAN         reduce using rule 48 (unaryoperator -> PLUS .)


state 52

    (49) unaryoperator -> MINUS .

    ID              reduce using rule 49 (unaryoperator -> MINUS .)
    LEFTPARENTHESIS reduce using rule 49 (unaryoperator -> MINUS .)
    INTEGER         reduce using rule 49 (unaryoperator -> MINUS .)
    NUMBER          reduce using rule 49 (unaryoperator -> MINUS .)
    STRING          reduce using rule 49 (unaryoperator -> MINUS .)
    BOOLEAN         reduce using rule 49 (unaryoperator -> MINUS .)


state 53

    (37) term -> fact .
    (38) term -> fact . TIMES term
    (39) term -> fact . MINUS term
    (40) term -> fact . DIVIDE term
    (41) term -> fact . AND term

  ! shift/reduce conflict for MINUS resolved as shift
    PLUS            reduce using rule 37 (term -> fact .)
    OR              reduce using rule 37 (term -> fact .)
    EQUAL           reduce using rule 37 (term -> fact .)
    LESSER          reduce using rule 37 (term -> fact .)
    GREATER         reduce using rule 37 (term -> fact .)
    LESSEREQUAL     reduce using rule 37 (term -> fact .)
    GREATEREQUAL    reduce using rule 37 (term -> fact .)
    RIGHTPARENTHESIS reduce using rule 37 (term -> fact .)
    SEMICOLON       reduce using rule 37 (term -> fact .)
    TIMES           shift and go to state 71
    MINUS           shift and go to state 72
    DIVIDE          shift and go to state 73
    AND             shift and go to state 74

  ! MINUS           [ reduce using rule 37 (term -> fact .) ]


state 54

    (42) fact -> unaryoperator . ID
    (43) fact -> unaryoperator . LEFTPARENTHESIS expression RIGHTPARENTHESIS
    (44) fact -> unaryoperator . INTEGER
    (45) fact -> unaryoperator . NUMBER
    (46) fact -> unaryoperator . STRING
    (47) fact -> unaryoperator . BOOLEAN

    ID              shift and go to state 75
    LEFTPARENTHESIS shift and go to state 76
    INTEGER         shift and go to state 77
    NUMBER          shift and go to state 78
    STRING          shift and go to state 79
    BOOLEAN         shift and go to state 80


state 55

    (50) unaryoperator -> empty .

    ID              reduce using rule 50 (unaryoperator -> empty .)
    LEFTPARENTHESIS reduce using rule 50 (unaryoperator -> empty .)
    INTEGER         reduce using rule 50 (unaryoperator -> empty .)
    NUMBER          reduce using rule 50 (unaryoperator -> empty .)
    STRING          reduce using rule 50 (unaryoperator -> empty .)
    BOOLEAN         reduce using rule 50 (unaryoperator -> empty .)


state 56

    (18) assignstatement -> ID ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 81


state 57

    (19) ifstatement -> IF LEFTPARENTHESIS expression . RIGHTPARENTHESIS THEN LEFTBRACKET statement RIGHTBRACKET elsestatement

    RIGHTPARENTHESIS shift and go to state 82


state 58

    (22) whileloop -> WHILE LEFTPARENTHESIS expression . RIGHTPARENTHESIS DO LEFTBRACKET statement RIGHTBRACKET

    RIGHTPARENTHESIS shift and go to state 83


state 59

    (23) forloop -> FOR LEFTPARENTHESIS ID . ASSIGN expression SEMICOLON expression SEMICOLON formodifier RIGHTPARENTHESIS LEFTBRACKET statement RIGHTBRACKET

    ASSIGN          shift and go to state 84


state 60

    (2) variable -> VAR ID variables COLON datatype SEMICOLON . variable
    (2) variable -> . VAR ID variables COLON datatype SEMICOLON variable
    (3) variable -> . empty
    (51) empty -> .

    VAR             shift and go to state 6
    BEGIN           reduce using rule 51 (empty -> .)

    variable                       shift and go to state 85
    empty                          shift and go to state 7

state 61

    (17) writestatement -> WRITE LEFTPARENTHESIS expression RIGHTPARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 86


state 62

    (27) expression -> simpleexpression relationaloperators . simpleexpression
    (33) simpleexpression -> . term
    (34) simpleexpression -> . term PLUS simpleexpression
    (35) simpleexpression -> . term MINUS simpleexpression
    (36) simpleexpression -> . term OR simpleexpression
    (37) term -> . fact
    (38) term -> . fact TIMES term
    (39) term -> . fact MINUS term
    (40) term -> . fact DIVIDE term
    (41) term -> . fact AND term
    (42) fact -> . unaryoperator ID
    (43) fact -> . unaryoperator LEFTPARENTHESIS expression RIGHTPARENTHESIS
    (44) fact -> . unaryoperator INTEGER
    (45) fact -> . unaryoperator NUMBER
    (46) fact -> . unaryoperator STRING
    (47) fact -> . unaryoperator BOOLEAN
    (48) unaryoperator -> . PLUS
    (49) unaryoperator -> . MINUS
    (50) unaryoperator -> . empty
    (51) empty -> .

    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    ID              reduce using rule 51 (empty -> .)
    LEFTPARENTHESIS reduce using rule 51 (empty -> .)
    INTEGER         reduce using rule 51 (empty -> .)
    NUMBER          reduce using rule 51 (empty -> .)
    STRING          reduce using rule 51 (empty -> .)
    BOOLEAN         reduce using rule 51 (empty -> .)

    simpleexpression               shift and go to state 87
    term                           shift and go to state 50
    fact                           shift and go to state 53
    unaryoperator                  shift and go to state 54
    empty                          shift and go to state 55

state 63

    (28) relationaloperators -> EQUAL .

    PLUS            reduce using rule 28 (relationaloperators -> EQUAL .)
    MINUS           reduce using rule 28 (relationaloperators -> EQUAL .)
    ID              reduce using rule 28 (relationaloperators -> EQUAL .)
    LEFTPARENTHESIS reduce using rule 28 (relationaloperators -> EQUAL .)
    INTEGER         reduce using rule 28 (relationaloperators -> EQUAL .)
    NUMBER          reduce using rule 28 (relationaloperators -> EQUAL .)
    STRING          reduce using rule 28 (relationaloperators -> EQUAL .)
    BOOLEAN         reduce using rule 28 (relationaloperators -> EQUAL .)


state 64

    (29) relationaloperators -> LESSER .

    PLUS            reduce using rule 29 (relationaloperators -> LESSER .)
    MINUS           reduce using rule 29 (relationaloperators -> LESSER .)
    ID              reduce using rule 29 (relationaloperators -> LESSER .)
    LEFTPARENTHESIS reduce using rule 29 (relationaloperators -> LESSER .)
    INTEGER         reduce using rule 29 (relationaloperators -> LESSER .)
    NUMBER          reduce using rule 29 (relationaloperators -> LESSER .)
    STRING          reduce using rule 29 (relationaloperators -> LESSER .)
    BOOLEAN         reduce using rule 29 (relationaloperators -> LESSER .)


state 65

    (30) relationaloperators -> GREATER .

    PLUS            reduce using rule 30 (relationaloperators -> GREATER .)
    MINUS           reduce using rule 30 (relationaloperators -> GREATER .)
    ID              reduce using rule 30 (relationaloperators -> GREATER .)
    LEFTPARENTHESIS reduce using rule 30 (relationaloperators -> GREATER .)
    INTEGER         reduce using rule 30 (relationaloperators -> GREATER .)
    NUMBER          reduce using rule 30 (relationaloperators -> GREATER .)
    STRING          reduce using rule 30 (relationaloperators -> GREATER .)
    BOOLEAN         reduce using rule 30 (relationaloperators -> GREATER .)


state 66

    (31) relationaloperators -> LESSEREQUAL .

    PLUS            reduce using rule 31 (relationaloperators -> LESSEREQUAL .)
    MINUS           reduce using rule 31 (relationaloperators -> LESSEREQUAL .)
    ID              reduce using rule 31 (relationaloperators -> LESSEREQUAL .)
    LEFTPARENTHESIS reduce using rule 31 (relationaloperators -> LESSEREQUAL .)
    INTEGER         reduce using rule 31 (relationaloperators -> LESSEREQUAL .)
    NUMBER          reduce using rule 31 (relationaloperators -> LESSEREQUAL .)
    STRING          reduce using rule 31 (relationaloperators -> LESSEREQUAL .)
    BOOLEAN         reduce using rule 31 (relationaloperators -> LESSEREQUAL .)


state 67

    (32) relationaloperators -> GREATEREQUAL .

    PLUS            reduce using rule 32 (relationaloperators -> GREATEREQUAL .)
    MINUS           reduce using rule 32 (relationaloperators -> GREATEREQUAL .)
    ID              reduce using rule 32 (relationaloperators -> GREATEREQUAL .)
    LEFTPARENTHESIS reduce using rule 32 (relationaloperators -> GREATEREQUAL .)
    INTEGER         reduce using rule 32 (relationaloperators -> GREATEREQUAL .)
    NUMBER          reduce using rule 32 (relationaloperators -> GREATEREQUAL .)
    STRING          reduce using rule 32 (relationaloperators -> GREATEREQUAL .)
    BOOLEAN         reduce using rule 32 (relationaloperators -> GREATEREQUAL .)


state 68

    (34) simpleexpression -> term PLUS . simpleexpression
    (33) simpleexpression -> . term
    (34) simpleexpression -> . term PLUS simpleexpression
    (35) simpleexpression -> . term MINUS simpleexpression
    (36) simpleexpression -> . term OR simpleexpression
    (37) term -> . fact
    (38) term -> . fact TIMES term
    (39) term -> . fact MINUS term
    (40) term -> . fact DIVIDE term
    (41) term -> . fact AND term
    (42) fact -> . unaryoperator ID
    (43) fact -> . unaryoperator LEFTPARENTHESIS expression RIGHTPARENTHESIS
    (44) fact -> . unaryoperator INTEGER
    (45) fact -> . unaryoperator NUMBER
    (46) fact -> . unaryoperator STRING
    (47) fact -> . unaryoperator BOOLEAN
    (48) unaryoperator -> . PLUS
    (49) unaryoperator -> . MINUS
    (50) unaryoperator -> . empty
    (51) empty -> .

    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    ID              reduce using rule 51 (empty -> .)
    LEFTPARENTHESIS reduce using rule 51 (empty -> .)
    INTEGER         reduce using rule 51 (empty -> .)
    NUMBER          reduce using rule 51 (empty -> .)
    STRING          reduce using rule 51 (empty -> .)
    BOOLEAN         reduce using rule 51 (empty -> .)

    term                           shift and go to state 50
    simpleexpression               shift and go to state 88
    fact                           shift and go to state 53
    unaryoperator                  shift and go to state 54
    empty                          shift and go to state 55

state 69

    (35) simpleexpression -> term MINUS . simpleexpression
    (33) simpleexpression -> . term
    (34) simpleexpression -> . term PLUS simpleexpression
    (35) simpleexpression -> . term MINUS simpleexpression
    (36) simpleexpression -> . term OR simpleexpression
    (37) term -> . fact
    (38) term -> . fact TIMES term
    (39) term -> . fact MINUS term
    (40) term -> . fact DIVIDE term
    (41) term -> . fact AND term
    (42) fact -> . unaryoperator ID
    (43) fact -> . unaryoperator LEFTPARENTHESIS expression RIGHTPARENTHESIS
    (44) fact -> . unaryoperator INTEGER
    (45) fact -> . unaryoperator NUMBER
    (46) fact -> . unaryoperator STRING
    (47) fact -> . unaryoperator BOOLEAN
    (48) unaryoperator -> . PLUS
    (49) unaryoperator -> . MINUS
    (50) unaryoperator -> . empty
    (51) empty -> .

    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    ID              reduce using rule 51 (empty -> .)
    LEFTPARENTHESIS reduce using rule 51 (empty -> .)
    INTEGER         reduce using rule 51 (empty -> .)
    NUMBER          reduce using rule 51 (empty -> .)
    STRING          reduce using rule 51 (empty -> .)
    BOOLEAN         reduce using rule 51 (empty -> .)

    term                           shift and go to state 50
    simpleexpression               shift and go to state 89
    fact                           shift and go to state 53
    unaryoperator                  shift and go to state 54
    empty                          shift and go to state 55

state 70

    (36) simpleexpression -> term OR . simpleexpression
    (33) simpleexpression -> . term
    (34) simpleexpression -> . term PLUS simpleexpression
    (35) simpleexpression -> . term MINUS simpleexpression
    (36) simpleexpression -> . term OR simpleexpression
    (37) term -> . fact
    (38) term -> . fact TIMES term
    (39) term -> . fact MINUS term
    (40) term -> . fact DIVIDE term
    (41) term -> . fact AND term
    (42) fact -> . unaryoperator ID
    (43) fact -> . unaryoperator LEFTPARENTHESIS expression RIGHTPARENTHESIS
    (44) fact -> . unaryoperator INTEGER
    (45) fact -> . unaryoperator NUMBER
    (46) fact -> . unaryoperator STRING
    (47) fact -> . unaryoperator BOOLEAN
    (48) unaryoperator -> . PLUS
    (49) unaryoperator -> . MINUS
    (50) unaryoperator -> . empty
    (51) empty -> .

    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    ID              reduce using rule 51 (empty -> .)
    LEFTPARENTHESIS reduce using rule 51 (empty -> .)
    INTEGER         reduce using rule 51 (empty -> .)
    NUMBER          reduce using rule 51 (empty -> .)
    STRING          reduce using rule 51 (empty -> .)
    BOOLEAN         reduce using rule 51 (empty -> .)

    term                           shift and go to state 50
    simpleexpression               shift and go to state 90
    fact                           shift and go to state 53
    unaryoperator                  shift and go to state 54
    empty                          shift and go to state 55

state 71

    (38) term -> fact TIMES . term
    (37) term -> . fact
    (38) term -> . fact TIMES term
    (39) term -> . fact MINUS term
    (40) term -> . fact DIVIDE term
    (41) term -> . fact AND term
    (42) fact -> . unaryoperator ID
    (43) fact -> . unaryoperator LEFTPARENTHESIS expression RIGHTPARENTHESIS
    (44) fact -> . unaryoperator INTEGER
    (45) fact -> . unaryoperator NUMBER
    (46) fact -> . unaryoperator STRING
    (47) fact -> . unaryoperator BOOLEAN
    (48) unaryoperator -> . PLUS
    (49) unaryoperator -> . MINUS
    (50) unaryoperator -> . empty
    (51) empty -> .

    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    ID              reduce using rule 51 (empty -> .)
    LEFTPARENTHESIS reduce using rule 51 (empty -> .)
    INTEGER         reduce using rule 51 (empty -> .)
    NUMBER          reduce using rule 51 (empty -> .)
    STRING          reduce using rule 51 (empty -> .)
    BOOLEAN         reduce using rule 51 (empty -> .)

    fact                           shift and go to state 53
    term                           shift and go to state 91
    unaryoperator                  shift and go to state 54
    empty                          shift and go to state 55

state 72

    (39) term -> fact MINUS . term
    (37) term -> . fact
    (38) term -> . fact TIMES term
    (39) term -> . fact MINUS term
    (40) term -> . fact DIVIDE term
    (41) term -> . fact AND term
    (42) fact -> . unaryoperator ID
    (43) fact -> . unaryoperator LEFTPARENTHESIS expression RIGHTPARENTHESIS
    (44) fact -> . unaryoperator INTEGER
    (45) fact -> . unaryoperator NUMBER
    (46) fact -> . unaryoperator STRING
    (47) fact -> . unaryoperator BOOLEAN
    (48) unaryoperator -> . PLUS
    (49) unaryoperator -> . MINUS
    (50) unaryoperator -> . empty
    (51) empty -> .

    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    ID              reduce using rule 51 (empty -> .)
    LEFTPARENTHESIS reduce using rule 51 (empty -> .)
    INTEGER         reduce using rule 51 (empty -> .)
    NUMBER          reduce using rule 51 (empty -> .)
    STRING          reduce using rule 51 (empty -> .)
    BOOLEAN         reduce using rule 51 (empty -> .)

    fact                           shift and go to state 53
    term                           shift and go to state 92
    unaryoperator                  shift and go to state 54
    empty                          shift and go to state 55

state 73

    (40) term -> fact DIVIDE . term
    (37) term -> . fact
    (38) term -> . fact TIMES term
    (39) term -> . fact MINUS term
    (40) term -> . fact DIVIDE term
    (41) term -> . fact AND term
    (42) fact -> . unaryoperator ID
    (43) fact -> . unaryoperator LEFTPARENTHESIS expression RIGHTPARENTHESIS
    (44) fact -> . unaryoperator INTEGER
    (45) fact -> . unaryoperator NUMBER
    (46) fact -> . unaryoperator STRING
    (47) fact -> . unaryoperator BOOLEAN
    (48) unaryoperator -> . PLUS
    (49) unaryoperator -> . MINUS
    (50) unaryoperator -> . empty
    (51) empty -> .

    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    ID              reduce using rule 51 (empty -> .)
    LEFTPARENTHESIS reduce using rule 51 (empty -> .)
    INTEGER         reduce using rule 51 (empty -> .)
    NUMBER          reduce using rule 51 (empty -> .)
    STRING          reduce using rule 51 (empty -> .)
    BOOLEAN         reduce using rule 51 (empty -> .)

    fact                           shift and go to state 53
    term                           shift and go to state 93
    unaryoperator                  shift and go to state 54
    empty                          shift and go to state 55

state 74

    (41) term -> fact AND . term
    (37) term -> . fact
    (38) term -> . fact TIMES term
    (39) term -> . fact MINUS term
    (40) term -> . fact DIVIDE term
    (41) term -> . fact AND term
    (42) fact -> . unaryoperator ID
    (43) fact -> . unaryoperator LEFTPARENTHESIS expression RIGHTPARENTHESIS
    (44) fact -> . unaryoperator INTEGER
    (45) fact -> . unaryoperator NUMBER
    (46) fact -> . unaryoperator STRING
    (47) fact -> . unaryoperator BOOLEAN
    (48) unaryoperator -> . PLUS
    (49) unaryoperator -> . MINUS
    (50) unaryoperator -> . empty
    (51) empty -> .

    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    ID              reduce using rule 51 (empty -> .)
    LEFTPARENTHESIS reduce using rule 51 (empty -> .)
    INTEGER         reduce using rule 51 (empty -> .)
    NUMBER          reduce using rule 51 (empty -> .)
    STRING          reduce using rule 51 (empty -> .)
    BOOLEAN         reduce using rule 51 (empty -> .)

    fact                           shift and go to state 53
    term                           shift and go to state 94
    unaryoperator                  shift and go to state 54
    empty                          shift and go to state 55

state 75

    (42) fact -> unaryoperator ID .

    TIMES           reduce using rule 42 (fact -> unaryoperator ID .)
    MINUS           reduce using rule 42 (fact -> unaryoperator ID .)
    DIVIDE          reduce using rule 42 (fact -> unaryoperator ID .)
    AND             reduce using rule 42 (fact -> unaryoperator ID .)
    PLUS            reduce using rule 42 (fact -> unaryoperator ID .)
    OR              reduce using rule 42 (fact -> unaryoperator ID .)
    EQUAL           reduce using rule 42 (fact -> unaryoperator ID .)
    LESSER          reduce using rule 42 (fact -> unaryoperator ID .)
    GREATER         reduce using rule 42 (fact -> unaryoperator ID .)
    LESSEREQUAL     reduce using rule 42 (fact -> unaryoperator ID .)
    GREATEREQUAL    reduce using rule 42 (fact -> unaryoperator ID .)
    RIGHTPARENTHESIS reduce using rule 42 (fact -> unaryoperator ID .)
    SEMICOLON       reduce using rule 42 (fact -> unaryoperator ID .)


state 76

    (43) fact -> unaryoperator LEFTPARENTHESIS . expression RIGHTPARENTHESIS
    (26) expression -> . simpleexpression
    (27) expression -> . simpleexpression relationaloperators simpleexpression
    (33) simpleexpression -> . term
    (34) simpleexpression -> . term PLUS simpleexpression
    (35) simpleexpression -> . term MINUS simpleexpression
    (36) simpleexpression -> . term OR simpleexpression
    (37) term -> . fact
    (38) term -> . fact TIMES term
    (39) term -> . fact MINUS term
    (40) term -> . fact DIVIDE term
    (41) term -> . fact AND term
    (42) fact -> . unaryoperator ID
    (43) fact -> . unaryoperator LEFTPARENTHESIS expression RIGHTPARENTHESIS
    (44) fact -> . unaryoperator INTEGER
    (45) fact -> . unaryoperator NUMBER
    (46) fact -> . unaryoperator STRING
    (47) fact -> . unaryoperator BOOLEAN
    (48) unaryoperator -> . PLUS
    (49) unaryoperator -> . MINUS
    (50) unaryoperator -> . empty
    (51) empty -> .

    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    ID              reduce using rule 51 (empty -> .)
    LEFTPARENTHESIS reduce using rule 51 (empty -> .)
    INTEGER         reduce using rule 51 (empty -> .)
    NUMBER          reduce using rule 51 (empty -> .)
    STRING          reduce using rule 51 (empty -> .)
    BOOLEAN         reduce using rule 51 (empty -> .)

    unaryoperator                  shift and go to state 54
    expression                     shift and go to state 95
    simpleexpression               shift and go to state 49
    term                           shift and go to state 50
    fact                           shift and go to state 53
    empty                          shift and go to state 55

state 77

    (44) fact -> unaryoperator INTEGER .

    TIMES           reduce using rule 44 (fact -> unaryoperator INTEGER .)
    MINUS           reduce using rule 44 (fact -> unaryoperator INTEGER .)
    DIVIDE          reduce using rule 44 (fact -> unaryoperator INTEGER .)
    AND             reduce using rule 44 (fact -> unaryoperator INTEGER .)
    PLUS            reduce using rule 44 (fact -> unaryoperator INTEGER .)
    OR              reduce using rule 44 (fact -> unaryoperator INTEGER .)
    EQUAL           reduce using rule 44 (fact -> unaryoperator INTEGER .)
    LESSER          reduce using rule 44 (fact -> unaryoperator INTEGER .)
    GREATER         reduce using rule 44 (fact -> unaryoperator INTEGER .)
    LESSEREQUAL     reduce using rule 44 (fact -> unaryoperator INTEGER .)
    GREATEREQUAL    reduce using rule 44 (fact -> unaryoperator INTEGER .)
    RIGHTPARENTHESIS reduce using rule 44 (fact -> unaryoperator INTEGER .)
    SEMICOLON       reduce using rule 44 (fact -> unaryoperator INTEGER .)


state 78

    (45) fact -> unaryoperator NUMBER .

    TIMES           reduce using rule 45 (fact -> unaryoperator NUMBER .)
    MINUS           reduce using rule 45 (fact -> unaryoperator NUMBER .)
    DIVIDE          reduce using rule 45 (fact -> unaryoperator NUMBER .)
    AND             reduce using rule 45 (fact -> unaryoperator NUMBER .)
    PLUS            reduce using rule 45 (fact -> unaryoperator NUMBER .)
    OR              reduce using rule 45 (fact -> unaryoperator NUMBER .)
    EQUAL           reduce using rule 45 (fact -> unaryoperator NUMBER .)
    LESSER          reduce using rule 45 (fact -> unaryoperator NUMBER .)
    GREATER         reduce using rule 45 (fact -> unaryoperator NUMBER .)
    LESSEREQUAL     reduce using rule 45 (fact -> unaryoperator NUMBER .)
    GREATEREQUAL    reduce using rule 45 (fact -> unaryoperator NUMBER .)
    RIGHTPARENTHESIS reduce using rule 45 (fact -> unaryoperator NUMBER .)
    SEMICOLON       reduce using rule 45 (fact -> unaryoperator NUMBER .)


state 79

    (46) fact -> unaryoperator STRING .

    TIMES           reduce using rule 46 (fact -> unaryoperator STRING .)
    MINUS           reduce using rule 46 (fact -> unaryoperator STRING .)
    DIVIDE          reduce using rule 46 (fact -> unaryoperator STRING .)
    AND             reduce using rule 46 (fact -> unaryoperator STRING .)
    PLUS            reduce using rule 46 (fact -> unaryoperator STRING .)
    OR              reduce using rule 46 (fact -> unaryoperator STRING .)
    EQUAL           reduce using rule 46 (fact -> unaryoperator STRING .)
    LESSER          reduce using rule 46 (fact -> unaryoperator STRING .)
    GREATER         reduce using rule 46 (fact -> unaryoperator STRING .)
    LESSEREQUAL     reduce using rule 46 (fact -> unaryoperator STRING .)
    GREATEREQUAL    reduce using rule 46 (fact -> unaryoperator STRING .)
    RIGHTPARENTHESIS reduce using rule 46 (fact -> unaryoperator STRING .)
    SEMICOLON       reduce using rule 46 (fact -> unaryoperator STRING .)


state 80

    (47) fact -> unaryoperator BOOLEAN .

    TIMES           reduce using rule 47 (fact -> unaryoperator BOOLEAN .)
    MINUS           reduce using rule 47 (fact -> unaryoperator BOOLEAN .)
    DIVIDE          reduce using rule 47 (fact -> unaryoperator BOOLEAN .)
    AND             reduce using rule 47 (fact -> unaryoperator BOOLEAN .)
    PLUS            reduce using rule 47 (fact -> unaryoperator BOOLEAN .)
    OR              reduce using rule 47 (fact -> unaryoperator BOOLEAN .)
    EQUAL           reduce using rule 47 (fact -> unaryoperator BOOLEAN .)
    LESSER          reduce using rule 47 (fact -> unaryoperator BOOLEAN .)
    GREATER         reduce using rule 47 (fact -> unaryoperator BOOLEAN .)
    LESSEREQUAL     reduce using rule 47 (fact -> unaryoperator BOOLEAN .)
    GREATEREQUAL    reduce using rule 47 (fact -> unaryoperator BOOLEAN .)
    RIGHTPARENTHESIS reduce using rule 47 (fact -> unaryoperator BOOLEAN .)
    SEMICOLON       reduce using rule 47 (fact -> unaryoperator BOOLEAN .)


state 81

    (18) assignstatement -> ID ASSIGN expression SEMICOLON .

    WRITE           reduce using rule 18 (assignstatement -> ID ASSIGN expression SEMICOLON .)
    ID              reduce using rule 18 (assignstatement -> ID ASSIGN expression SEMICOLON .)
    IF              reduce using rule 18 (assignstatement -> ID ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 18 (assignstatement -> ID ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 18 (assignstatement -> ID ASSIGN expression SEMICOLON .)
    END             reduce using rule 18 (assignstatement -> ID ASSIGN expression SEMICOLON .)
    RIGHTBRACKET    reduce using rule 18 (assignstatement -> ID ASSIGN expression SEMICOLON .)


state 82

    (19) ifstatement -> IF LEFTPARENTHESIS expression RIGHTPARENTHESIS . THEN LEFTBRACKET statement RIGHTBRACKET elsestatement

    THEN            shift and go to state 96


state 83

    (22) whileloop -> WHILE LEFTPARENTHESIS expression RIGHTPARENTHESIS . DO LEFTBRACKET statement RIGHTBRACKET

    DO              shift and go to state 97


state 84

    (23) forloop -> FOR LEFTPARENTHESIS ID ASSIGN . expression SEMICOLON expression SEMICOLON formodifier RIGHTPARENTHESIS LEFTBRACKET statement RIGHTBRACKET
    (26) expression -> . simpleexpression
    (27) expression -> . simpleexpression relationaloperators simpleexpression
    (33) simpleexpression -> . term
    (34) simpleexpression -> . term PLUS simpleexpression
    (35) simpleexpression -> . term MINUS simpleexpression
    (36) simpleexpression -> . term OR simpleexpression
    (37) term -> . fact
    (38) term -> . fact TIMES term
    (39) term -> . fact MINUS term
    (40) term -> . fact DIVIDE term
    (41) term -> . fact AND term
    (42) fact -> . unaryoperator ID
    (43) fact -> . unaryoperator LEFTPARENTHESIS expression RIGHTPARENTHESIS
    (44) fact -> . unaryoperator INTEGER
    (45) fact -> . unaryoperator NUMBER
    (46) fact -> . unaryoperator STRING
    (47) fact -> . unaryoperator BOOLEAN
    (48) unaryoperator -> . PLUS
    (49) unaryoperator -> . MINUS
    (50) unaryoperator -> . empty
    (51) empty -> .

    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    ID              reduce using rule 51 (empty -> .)
    LEFTPARENTHESIS reduce using rule 51 (empty -> .)
    INTEGER         reduce using rule 51 (empty -> .)
    NUMBER          reduce using rule 51 (empty -> .)
    STRING          reduce using rule 51 (empty -> .)
    BOOLEAN         reduce using rule 51 (empty -> .)

    expression                     shift and go to state 98
    simpleexpression               shift and go to state 49
    term                           shift and go to state 50
    fact                           shift and go to state 53
    unaryoperator                  shift and go to state 54
    empty                          shift and go to state 55

state 85

    (2) variable -> VAR ID variables COLON datatype SEMICOLON variable .

    BEGIN           reduce using rule 2 (variable -> VAR ID variables COLON datatype SEMICOLON variable .)


state 86

    (17) writestatement -> WRITE LEFTPARENTHESIS expression RIGHTPARENTHESIS SEMICOLON .

    WRITE           reduce using rule 17 (writestatement -> WRITE LEFTPARENTHESIS expression RIGHTPARENTHESIS SEMICOLON .)
    ID              reduce using rule 17 (writestatement -> WRITE LEFTPARENTHESIS expression RIGHTPARENTHESIS SEMICOLON .)
    IF              reduce using rule 17 (writestatement -> WRITE LEFTPARENTHESIS expression RIGHTPARENTHESIS SEMICOLON .)
    WHILE           reduce using rule 17 (writestatement -> WRITE LEFTPARENTHESIS expression RIGHTPARENTHESIS SEMICOLON .)
    FOR             reduce using rule 17 (writestatement -> WRITE LEFTPARENTHESIS expression RIGHTPARENTHESIS SEMICOLON .)
    END             reduce using rule 17 (writestatement -> WRITE LEFTPARENTHESIS expression RIGHTPARENTHESIS SEMICOLON .)
    RIGHTBRACKET    reduce using rule 17 (writestatement -> WRITE LEFTPARENTHESIS expression RIGHTPARENTHESIS SEMICOLON .)


state 87

    (27) expression -> simpleexpression relationaloperators simpleexpression .

    RIGHTPARENTHESIS reduce using rule 27 (expression -> simpleexpression relationaloperators simpleexpression .)
    SEMICOLON       reduce using rule 27 (expression -> simpleexpression relationaloperators simpleexpression .)


state 88

    (34) simpleexpression -> term PLUS simpleexpression .

    EQUAL           reduce using rule 34 (simpleexpression -> term PLUS simpleexpression .)
    LESSER          reduce using rule 34 (simpleexpression -> term PLUS simpleexpression .)
    GREATER         reduce using rule 34 (simpleexpression -> term PLUS simpleexpression .)
    LESSEREQUAL     reduce using rule 34 (simpleexpression -> term PLUS simpleexpression .)
    GREATEREQUAL    reduce using rule 34 (simpleexpression -> term PLUS simpleexpression .)
    RIGHTPARENTHESIS reduce using rule 34 (simpleexpression -> term PLUS simpleexpression .)
    SEMICOLON       reduce using rule 34 (simpleexpression -> term PLUS simpleexpression .)


state 89

    (35) simpleexpression -> term MINUS simpleexpression .

    EQUAL           reduce using rule 35 (simpleexpression -> term MINUS simpleexpression .)
    LESSER          reduce using rule 35 (simpleexpression -> term MINUS simpleexpression .)
    GREATER         reduce using rule 35 (simpleexpression -> term MINUS simpleexpression .)
    LESSEREQUAL     reduce using rule 35 (simpleexpression -> term MINUS simpleexpression .)
    GREATEREQUAL    reduce using rule 35 (simpleexpression -> term MINUS simpleexpression .)
    RIGHTPARENTHESIS reduce using rule 35 (simpleexpression -> term MINUS simpleexpression .)
    SEMICOLON       reduce using rule 35 (simpleexpression -> term MINUS simpleexpression .)


state 90

    (36) simpleexpression -> term OR simpleexpression .

    EQUAL           reduce using rule 36 (simpleexpression -> term OR simpleexpression .)
    LESSER          reduce using rule 36 (simpleexpression -> term OR simpleexpression .)
    GREATER         reduce using rule 36 (simpleexpression -> term OR simpleexpression .)
    LESSEREQUAL     reduce using rule 36 (simpleexpression -> term OR simpleexpression .)
    GREATEREQUAL    reduce using rule 36 (simpleexpression -> term OR simpleexpression .)
    RIGHTPARENTHESIS reduce using rule 36 (simpleexpression -> term OR simpleexpression .)
    SEMICOLON       reduce using rule 36 (simpleexpression -> term OR simpleexpression .)


state 91

    (38) term -> fact TIMES term .

    PLUS            reduce using rule 38 (term -> fact TIMES term .)
    MINUS           reduce using rule 38 (term -> fact TIMES term .)
    OR              reduce using rule 38 (term -> fact TIMES term .)
    EQUAL           reduce using rule 38 (term -> fact TIMES term .)
    LESSER          reduce using rule 38 (term -> fact TIMES term .)
    GREATER         reduce using rule 38 (term -> fact TIMES term .)
    LESSEREQUAL     reduce using rule 38 (term -> fact TIMES term .)
    GREATEREQUAL    reduce using rule 38 (term -> fact TIMES term .)
    RIGHTPARENTHESIS reduce using rule 38 (term -> fact TIMES term .)
    SEMICOLON       reduce using rule 38 (term -> fact TIMES term .)


state 92

    (39) term -> fact MINUS term .

    PLUS            reduce using rule 39 (term -> fact MINUS term .)
    MINUS           reduce using rule 39 (term -> fact MINUS term .)
    OR              reduce using rule 39 (term -> fact MINUS term .)
    EQUAL           reduce using rule 39 (term -> fact MINUS term .)
    LESSER          reduce using rule 39 (term -> fact MINUS term .)
    GREATER         reduce using rule 39 (term -> fact MINUS term .)
    LESSEREQUAL     reduce using rule 39 (term -> fact MINUS term .)
    GREATEREQUAL    reduce using rule 39 (term -> fact MINUS term .)
    RIGHTPARENTHESIS reduce using rule 39 (term -> fact MINUS term .)
    SEMICOLON       reduce using rule 39 (term -> fact MINUS term .)


state 93

    (40) term -> fact DIVIDE term .

    PLUS            reduce using rule 40 (term -> fact DIVIDE term .)
    MINUS           reduce using rule 40 (term -> fact DIVIDE term .)
    OR              reduce using rule 40 (term -> fact DIVIDE term .)
    EQUAL           reduce using rule 40 (term -> fact DIVIDE term .)
    LESSER          reduce using rule 40 (term -> fact DIVIDE term .)
    GREATER         reduce using rule 40 (term -> fact DIVIDE term .)
    LESSEREQUAL     reduce using rule 40 (term -> fact DIVIDE term .)
    GREATEREQUAL    reduce using rule 40 (term -> fact DIVIDE term .)
    RIGHTPARENTHESIS reduce using rule 40 (term -> fact DIVIDE term .)
    SEMICOLON       reduce using rule 40 (term -> fact DIVIDE term .)


state 94

    (41) term -> fact AND term .

    PLUS            reduce using rule 41 (term -> fact AND term .)
    MINUS           reduce using rule 41 (term -> fact AND term .)
    OR              reduce using rule 41 (term -> fact AND term .)
    EQUAL           reduce using rule 41 (term -> fact AND term .)
    LESSER          reduce using rule 41 (term -> fact AND term .)
    GREATER         reduce using rule 41 (term -> fact AND term .)
    LESSEREQUAL     reduce using rule 41 (term -> fact AND term .)
    GREATEREQUAL    reduce using rule 41 (term -> fact AND term .)
    RIGHTPARENTHESIS reduce using rule 41 (term -> fact AND term .)
    SEMICOLON       reduce using rule 41 (term -> fact AND term .)


state 95

    (43) fact -> unaryoperator LEFTPARENTHESIS expression . RIGHTPARENTHESIS

    RIGHTPARENTHESIS shift and go to state 99


state 96

    (19) ifstatement -> IF LEFTPARENTHESIS expression RIGHTPARENTHESIS THEN . LEFTBRACKET statement RIGHTBRACKET elsestatement

    LEFTBRACKET     shift and go to state 100


state 97

    (22) whileloop -> WHILE LEFTPARENTHESIS expression RIGHTPARENTHESIS DO . LEFTBRACKET statement RIGHTBRACKET

    LEFTBRACKET     shift and go to state 101


state 98

    (23) forloop -> FOR LEFTPARENTHESIS ID ASSIGN expression . SEMICOLON expression SEMICOLON formodifier RIGHTPARENTHESIS LEFTBRACKET statement RIGHTBRACKET

    SEMICOLON       shift and go to state 102


state 99

    (43) fact -> unaryoperator LEFTPARENTHESIS expression RIGHTPARENTHESIS .

    TIMES           reduce using rule 43 (fact -> unaryoperator LEFTPARENTHESIS expression RIGHTPARENTHESIS .)
    MINUS           reduce using rule 43 (fact -> unaryoperator LEFTPARENTHESIS expression RIGHTPARENTHESIS .)
    DIVIDE          reduce using rule 43 (fact -> unaryoperator LEFTPARENTHESIS expression RIGHTPARENTHESIS .)
    AND             reduce using rule 43 (fact -> unaryoperator LEFTPARENTHESIS expression RIGHTPARENTHESIS .)
    PLUS            reduce using rule 43 (fact -> unaryoperator LEFTPARENTHESIS expression RIGHTPARENTHESIS .)
    OR              reduce using rule 43 (fact -> unaryoperator LEFTPARENTHESIS expression RIGHTPARENTHESIS .)
    EQUAL           reduce using rule 43 (fact -> unaryoperator LEFTPARENTHESIS expression RIGHTPARENTHESIS .)
    LESSER          reduce using rule 43 (fact -> unaryoperator LEFTPARENTHESIS expression RIGHTPARENTHESIS .)
    GREATER         reduce using rule 43 (fact -> unaryoperator LEFTPARENTHESIS expression RIGHTPARENTHESIS .)
    LESSEREQUAL     reduce using rule 43 (fact -> unaryoperator LEFTPARENTHESIS expression RIGHTPARENTHESIS .)
    GREATEREQUAL    reduce using rule 43 (fact -> unaryoperator LEFTPARENTHESIS expression RIGHTPARENTHESIS .)
    RIGHTPARENTHESIS reduce using rule 43 (fact -> unaryoperator LEFTPARENTHESIS expression RIGHTPARENTHESIS .)
    SEMICOLON       reduce using rule 43 (fact -> unaryoperator LEFTPARENTHESIS expression RIGHTPARENTHESIS .)


state 100

    (19) ifstatement -> IF LEFTPARENTHESIS expression RIGHTPARENTHESIS THEN LEFTBRACKET . statement RIGHTBRACKET elsestatement
    (11) statement -> . writestatement statement
    (12) statement -> . assignstatement statement
    (13) statement -> . ifstatement statement
    (14) statement -> . whileloop statement
    (15) statement -> . forloop statement
    (16) statement -> . empty
    (17) writestatement -> . WRITE LEFTPARENTHESIS expression RIGHTPARENTHESIS SEMICOLON
    (18) assignstatement -> . ID ASSIGN expression SEMICOLON
    (19) ifstatement -> . IF LEFTPARENTHESIS expression RIGHTPARENTHESIS THEN LEFTBRACKET statement RIGHTBRACKET elsestatement
    (22) whileloop -> . WHILE LEFTPARENTHESIS expression RIGHTPARENTHESIS DO LEFTBRACKET statement RIGHTBRACKET
    (23) forloop -> . FOR LEFTPARENTHESIS ID ASSIGN expression SEMICOLON expression SEMICOLON formodifier RIGHTPARENTHESIS LEFTBRACKET statement RIGHTBRACKET
    (51) empty -> .

    WRITE           shift and go to state 23
    ID              shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    RIGHTBRACKET    reduce using rule 51 (empty -> .)

    statement                      shift and go to state 103
    writestatement                 shift and go to state 17
    assignstatement                shift and go to state 18
    ifstatement                    shift and go to state 19
    whileloop                      shift and go to state 20
    forloop                        shift and go to state 21
    empty                          shift and go to state 22

state 101

    (22) whileloop -> WHILE LEFTPARENTHESIS expression RIGHTPARENTHESIS DO LEFTBRACKET . statement RIGHTBRACKET
    (11) statement -> . writestatement statement
    (12) statement -> . assignstatement statement
    (13) statement -> . ifstatement statement
    (14) statement -> . whileloop statement
    (15) statement -> . forloop statement
    (16) statement -> . empty
    (17) writestatement -> . WRITE LEFTPARENTHESIS expression RIGHTPARENTHESIS SEMICOLON
    (18) assignstatement -> . ID ASSIGN expression SEMICOLON
    (19) ifstatement -> . IF LEFTPARENTHESIS expression RIGHTPARENTHESIS THEN LEFTBRACKET statement RIGHTBRACKET elsestatement
    (22) whileloop -> . WHILE LEFTPARENTHESIS expression RIGHTPARENTHESIS DO LEFTBRACKET statement RIGHTBRACKET
    (23) forloop -> . FOR LEFTPARENTHESIS ID ASSIGN expression SEMICOLON expression SEMICOLON formodifier RIGHTPARENTHESIS LEFTBRACKET statement RIGHTBRACKET
    (51) empty -> .

    WRITE           shift and go to state 23
    ID              shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    RIGHTBRACKET    reduce using rule 51 (empty -> .)

    statement                      shift and go to state 104
    writestatement                 shift and go to state 17
    assignstatement                shift and go to state 18
    ifstatement                    shift and go to state 19
    whileloop                      shift and go to state 20
    forloop                        shift and go to state 21
    empty                          shift and go to state 22

state 102

    (23) forloop -> FOR LEFTPARENTHESIS ID ASSIGN expression SEMICOLON . expression SEMICOLON formodifier RIGHTPARENTHESIS LEFTBRACKET statement RIGHTBRACKET
    (26) expression -> . simpleexpression
    (27) expression -> . simpleexpression relationaloperators simpleexpression
    (33) simpleexpression -> . term
    (34) simpleexpression -> . term PLUS simpleexpression
    (35) simpleexpression -> . term MINUS simpleexpression
    (36) simpleexpression -> . term OR simpleexpression
    (37) term -> . fact
    (38) term -> . fact TIMES term
    (39) term -> . fact MINUS term
    (40) term -> . fact DIVIDE term
    (41) term -> . fact AND term
    (42) fact -> . unaryoperator ID
    (43) fact -> . unaryoperator LEFTPARENTHESIS expression RIGHTPARENTHESIS
    (44) fact -> . unaryoperator INTEGER
    (45) fact -> . unaryoperator NUMBER
    (46) fact -> . unaryoperator STRING
    (47) fact -> . unaryoperator BOOLEAN
    (48) unaryoperator -> . PLUS
    (49) unaryoperator -> . MINUS
    (50) unaryoperator -> . empty
    (51) empty -> .

    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    ID              reduce using rule 51 (empty -> .)
    LEFTPARENTHESIS reduce using rule 51 (empty -> .)
    INTEGER         reduce using rule 51 (empty -> .)
    NUMBER          reduce using rule 51 (empty -> .)
    STRING          reduce using rule 51 (empty -> .)
    BOOLEAN         reduce using rule 51 (empty -> .)

    expression                     shift and go to state 105
    simpleexpression               shift and go to state 49
    term                           shift and go to state 50
    fact                           shift and go to state 53
    unaryoperator                  shift and go to state 54
    empty                          shift and go to state 55

state 103

    (19) ifstatement -> IF LEFTPARENTHESIS expression RIGHTPARENTHESIS THEN LEFTBRACKET statement . RIGHTBRACKET elsestatement

    RIGHTBRACKET    shift and go to state 106


state 104

    (22) whileloop -> WHILE LEFTPARENTHESIS expression RIGHTPARENTHESIS DO LEFTBRACKET statement . RIGHTBRACKET

    RIGHTBRACKET    shift and go to state 107


state 105

    (23) forloop -> FOR LEFTPARENTHESIS ID ASSIGN expression SEMICOLON expression . SEMICOLON formodifier RIGHTPARENTHESIS LEFTBRACKET statement RIGHTBRACKET

    SEMICOLON       shift and go to state 108


state 106

    (19) ifstatement -> IF LEFTPARENTHESIS expression RIGHTPARENTHESIS THEN LEFTBRACKET statement RIGHTBRACKET . elsestatement
    (20) elsestatement -> . ELSE LEFTBRACKET statement RIGHTBRACKET
    (21) elsestatement -> . empty
    (51) empty -> .

    ELSE            shift and go to state 110
    WRITE           reduce using rule 51 (empty -> .)
    ID              reduce using rule 51 (empty -> .)
    IF              reduce using rule 51 (empty -> .)
    WHILE           reduce using rule 51 (empty -> .)
    FOR             reduce using rule 51 (empty -> .)
    END             reduce using rule 51 (empty -> .)
    RIGHTBRACKET    reduce using rule 51 (empty -> .)

    elsestatement                  shift and go to state 109
    empty                          shift and go to state 111

state 107

    (22) whileloop -> WHILE LEFTPARENTHESIS expression RIGHTPARENTHESIS DO LEFTBRACKET statement RIGHTBRACKET .

    WRITE           reduce using rule 22 (whileloop -> WHILE LEFTPARENTHESIS expression RIGHTPARENTHESIS DO LEFTBRACKET statement RIGHTBRACKET .)
    ID              reduce using rule 22 (whileloop -> WHILE LEFTPARENTHESIS expression RIGHTPARENTHESIS DO LEFTBRACKET statement RIGHTBRACKET .)
    IF              reduce using rule 22 (whileloop -> WHILE LEFTPARENTHESIS expression RIGHTPARENTHESIS DO LEFTBRACKET statement RIGHTBRACKET .)
    WHILE           reduce using rule 22 (whileloop -> WHILE LEFTPARENTHESIS expression RIGHTPARENTHESIS DO LEFTBRACKET statement RIGHTBRACKET .)
    FOR             reduce using rule 22 (whileloop -> WHILE LEFTPARENTHESIS expression RIGHTPARENTHESIS DO LEFTBRACKET statement RIGHTBRACKET .)
    END             reduce using rule 22 (whileloop -> WHILE LEFTPARENTHESIS expression RIGHTPARENTHESIS DO LEFTBRACKET statement RIGHTBRACKET .)
    RIGHTBRACKET    reduce using rule 22 (whileloop -> WHILE LEFTPARENTHESIS expression RIGHTPARENTHESIS DO LEFTBRACKET statement RIGHTBRACKET .)


state 108

    (23) forloop -> FOR LEFTPARENTHESIS ID ASSIGN expression SEMICOLON expression SEMICOLON . formodifier RIGHTPARENTHESIS LEFTBRACKET statement RIGHTBRACKET
    (24) formodifier -> . ID PLUSPLUS
    (25) formodifier -> . ID MINUSMINUS

    ID              shift and go to state 112

    formodifier                    shift and go to state 113

state 109

    (19) ifstatement -> IF LEFTPARENTHESIS expression RIGHTPARENTHESIS THEN LEFTBRACKET statement RIGHTBRACKET elsestatement .

    WRITE           reduce using rule 19 (ifstatement -> IF LEFTPARENTHESIS expression RIGHTPARENTHESIS THEN LEFTBRACKET statement RIGHTBRACKET elsestatement .)
    ID              reduce using rule 19 (ifstatement -> IF LEFTPARENTHESIS expression RIGHTPARENTHESIS THEN LEFTBRACKET statement RIGHTBRACKET elsestatement .)
    IF              reduce using rule 19 (ifstatement -> IF LEFTPARENTHESIS expression RIGHTPARENTHESIS THEN LEFTBRACKET statement RIGHTBRACKET elsestatement .)
    WHILE           reduce using rule 19 (ifstatement -> IF LEFTPARENTHESIS expression RIGHTPARENTHESIS THEN LEFTBRACKET statement RIGHTBRACKET elsestatement .)
    FOR             reduce using rule 19 (ifstatement -> IF LEFTPARENTHESIS expression RIGHTPARENTHESIS THEN LEFTBRACKET statement RIGHTBRACKET elsestatement .)
    END             reduce using rule 19 (ifstatement -> IF LEFTPARENTHESIS expression RIGHTPARENTHESIS THEN LEFTBRACKET statement RIGHTBRACKET elsestatement .)
    RIGHTBRACKET    reduce using rule 19 (ifstatement -> IF LEFTPARENTHESIS expression RIGHTPARENTHESIS THEN LEFTBRACKET statement RIGHTBRACKET elsestatement .)


state 110

    (20) elsestatement -> ELSE . LEFTBRACKET statement RIGHTBRACKET

    LEFTBRACKET     shift and go to state 114


state 111

    (21) elsestatement -> empty .

    WRITE           reduce using rule 21 (elsestatement -> empty .)
    ID              reduce using rule 21 (elsestatement -> empty .)
    IF              reduce using rule 21 (elsestatement -> empty .)
    WHILE           reduce using rule 21 (elsestatement -> empty .)
    FOR             reduce using rule 21 (elsestatement -> empty .)
    END             reduce using rule 21 (elsestatement -> empty .)
    RIGHTBRACKET    reduce using rule 21 (elsestatement -> empty .)


state 112

    (24) formodifier -> ID . PLUSPLUS
    (25) formodifier -> ID . MINUSMINUS

    PLUSPLUS        shift and go to state 115
    MINUSMINUS      shift and go to state 116


state 113

    (23) forloop -> FOR LEFTPARENTHESIS ID ASSIGN expression SEMICOLON expression SEMICOLON formodifier . RIGHTPARENTHESIS LEFTBRACKET statement RIGHTBRACKET

    RIGHTPARENTHESIS shift and go to state 117


state 114

    (20) elsestatement -> ELSE LEFTBRACKET . statement RIGHTBRACKET
    (11) statement -> . writestatement statement
    (12) statement -> . assignstatement statement
    (13) statement -> . ifstatement statement
    (14) statement -> . whileloop statement
    (15) statement -> . forloop statement
    (16) statement -> . empty
    (17) writestatement -> . WRITE LEFTPARENTHESIS expression RIGHTPARENTHESIS SEMICOLON
    (18) assignstatement -> . ID ASSIGN expression SEMICOLON
    (19) ifstatement -> . IF LEFTPARENTHESIS expression RIGHTPARENTHESIS THEN LEFTBRACKET statement RIGHTBRACKET elsestatement
    (22) whileloop -> . WHILE LEFTPARENTHESIS expression RIGHTPARENTHESIS DO LEFTBRACKET statement RIGHTBRACKET
    (23) forloop -> . FOR LEFTPARENTHESIS ID ASSIGN expression SEMICOLON expression SEMICOLON formodifier RIGHTPARENTHESIS LEFTBRACKET statement RIGHTBRACKET
    (51) empty -> .

    WRITE           shift and go to state 23
    ID              shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    RIGHTBRACKET    reduce using rule 51 (empty -> .)

    statement                      shift and go to state 118
    writestatement                 shift and go to state 17
    assignstatement                shift and go to state 18
    ifstatement                    shift and go to state 19
    whileloop                      shift and go to state 20
    forloop                        shift and go to state 21
    empty                          shift and go to state 22

state 115

    (24) formodifier -> ID PLUSPLUS .

    RIGHTPARENTHESIS reduce using rule 24 (formodifier -> ID PLUSPLUS .)


state 116

    (25) formodifier -> ID MINUSMINUS .

    RIGHTPARENTHESIS reduce using rule 25 (formodifier -> ID MINUSMINUS .)


state 117

    (23) forloop -> FOR LEFTPARENTHESIS ID ASSIGN expression SEMICOLON expression SEMICOLON formodifier RIGHTPARENTHESIS . LEFTBRACKET statement RIGHTBRACKET

    LEFTBRACKET     shift and go to state 119


state 118

    (20) elsestatement -> ELSE LEFTBRACKET statement . RIGHTBRACKET

    RIGHTBRACKET    shift and go to state 120


state 119

    (23) forloop -> FOR LEFTPARENTHESIS ID ASSIGN expression SEMICOLON expression SEMICOLON formodifier RIGHTPARENTHESIS LEFTBRACKET . statement RIGHTBRACKET
    (11) statement -> . writestatement statement
    (12) statement -> . assignstatement statement
    (13) statement -> . ifstatement statement
    (14) statement -> . whileloop statement
    (15) statement -> . forloop statement
    (16) statement -> . empty
    (17) writestatement -> . WRITE LEFTPARENTHESIS expression RIGHTPARENTHESIS SEMICOLON
    (18) assignstatement -> . ID ASSIGN expression SEMICOLON
    (19) ifstatement -> . IF LEFTPARENTHESIS expression RIGHTPARENTHESIS THEN LEFTBRACKET statement RIGHTBRACKET elsestatement
    (22) whileloop -> . WHILE LEFTPARENTHESIS expression RIGHTPARENTHESIS DO LEFTBRACKET statement RIGHTBRACKET
    (23) forloop -> . FOR LEFTPARENTHESIS ID ASSIGN expression SEMICOLON expression SEMICOLON formodifier RIGHTPARENTHESIS LEFTBRACKET statement RIGHTBRACKET
    (51) empty -> .

    WRITE           shift and go to state 23
    ID              shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    RIGHTBRACKET    reduce using rule 51 (empty -> .)

    statement                      shift and go to state 121
    writestatement                 shift and go to state 17
    assignstatement                shift and go to state 18
    ifstatement                    shift and go to state 19
    whileloop                      shift and go to state 20
    forloop                        shift and go to state 21
    empty                          shift and go to state 22

state 120

    (20) elsestatement -> ELSE LEFTBRACKET statement RIGHTBRACKET .

    WRITE           reduce using rule 20 (elsestatement -> ELSE LEFTBRACKET statement RIGHTBRACKET .)
    ID              reduce using rule 20 (elsestatement -> ELSE LEFTBRACKET statement RIGHTBRACKET .)
    IF              reduce using rule 20 (elsestatement -> ELSE LEFTBRACKET statement RIGHTBRACKET .)
    WHILE           reduce using rule 20 (elsestatement -> ELSE LEFTBRACKET statement RIGHTBRACKET .)
    FOR             reduce using rule 20 (elsestatement -> ELSE LEFTBRACKET statement RIGHTBRACKET .)
    END             reduce using rule 20 (elsestatement -> ELSE LEFTBRACKET statement RIGHTBRACKET .)
    RIGHTBRACKET    reduce using rule 20 (elsestatement -> ELSE LEFTBRACKET statement RIGHTBRACKET .)


state 121

    (23) forloop -> FOR LEFTPARENTHESIS ID ASSIGN expression SEMICOLON expression SEMICOLON formodifier RIGHTPARENTHESIS LEFTBRACKET statement . RIGHTBRACKET

    RIGHTBRACKET    shift and go to state 122


state 122

    (23) forloop -> FOR LEFTPARENTHESIS ID ASSIGN expression SEMICOLON expression SEMICOLON formodifier RIGHTPARENTHESIS LEFTBRACKET statement RIGHTBRACKET .

    WRITE           reduce using rule 23 (forloop -> FOR LEFTPARENTHESIS ID ASSIGN expression SEMICOLON expression SEMICOLON formodifier RIGHTPARENTHESIS LEFTBRACKET statement RIGHTBRACKET .)
    ID              reduce using rule 23 (forloop -> FOR LEFTPARENTHESIS ID ASSIGN expression SEMICOLON expression SEMICOLON formodifier RIGHTPARENTHESIS LEFTBRACKET statement RIGHTBRACKET .)
    IF              reduce using rule 23 (forloop -> FOR LEFTPARENTHESIS ID ASSIGN expression SEMICOLON expression SEMICOLON formodifier RIGHTPARENTHESIS LEFTBRACKET statement RIGHTBRACKET .)
    WHILE           reduce using rule 23 (forloop -> FOR LEFTPARENTHESIS ID ASSIGN expression SEMICOLON expression SEMICOLON formodifier RIGHTPARENTHESIS LEFTBRACKET statement RIGHTBRACKET .)
    FOR             reduce using rule 23 (forloop -> FOR LEFTPARENTHESIS ID ASSIGN expression SEMICOLON expression SEMICOLON formodifier RIGHTPARENTHESIS LEFTBRACKET statement RIGHTBRACKET .)
    END             reduce using rule 23 (forloop -> FOR LEFTPARENTHESIS ID ASSIGN expression SEMICOLON expression SEMICOLON formodifier RIGHTPARENTHESIS LEFTBRACKET statement RIGHTBRACKET .)
    RIGHTBRACKET    reduce using rule 23 (forloop -> FOR LEFTPARENTHESIS ID ASSIGN expression SEMICOLON expression SEMICOLON formodifier RIGHTPARENTHESIS LEFTBRACKET statement RIGHTBRACKET .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for MINUS in state 53 resolved as shift
